# ポインタあれこれ
#golang 

## TL;DR

:heavy_check_mark: アンパサンド(`&`): 変数の前に付け、 ポインタ を返す
:heavy_check_mark: アスタリスク(`*`): ポインタの前に付け、変数(格納されているオブジェクト)を返す
:heavy_check_mark: アスタリスク その2(`*`): 型の前に付け、ポインタ型の宣言に使う

## はじめに

以降では「ポインタ型変数」のことを「ポインタ」と表す。

## そもそもポインタとは

### ポインタとは

変数(オブジェクト)のアドレスを格納する変数

### ポインタ"型"とは

前提として、通常の型による差異はざっくり以下の2つ

- サイズ
- 扱われ方

これに対し、ポインタ型は、**全ての型でサイズは同じ**(たぶん
int?)。通常型と異なり、ポインタ型での差異はざっくり以下の2つ。

- 対象(=アクセス先のデータ)の型
- 加減算時のアドレス増減値

例えば、以下は配列xの値を全て0にする関数。
まず `*p` とした時に表されるのは char でも double でもなく `int` である。
さらに `p++;` の式でポインタを加算しているが、 配列xが1000番地から始まっていたとすると、p+1=1004という計算がなされている。
これらは、ひとえに p がintのポインタ型だからである。

```c=
int x[5] = { 1, 2, 3, 4, 5 };
int *p;

void main()
{
        p = x;
        for( int i = 0; i < 5; i++ ){
                *p = 0;
                p++;
        }
}
```

## 忌まわしき C 言語の記憶

C 言語でのポインタ型変数 p を定義するときは以下。

```c
int *p
```

なんで `*` がそっち行った？

## Go におけるポインタとポインタ型

### Level 1: int型の変数p

```go=
var p int
p = 3
```

### Level 2: int型の変数pのポインタpp

```go=
p := 3

var pp *int
pp = &p
```

### Level 3: ポインタppが指すオブジェクトp

```go=
pp := &3  // 実際はコンパイルエラー起こすので別の変数を用意する

var p int
p = *pp
```

## (余談) 引数やレシーバには通常の変数？もしくはポインタ型変数？

[Goにおけるポインタの使いどころ](https://zenn.dev/uji/articles/f6ab9a06320294146733) を参照。

要約すると

- 迷ったらポインタ
- ポインタを使うべきケースは以下
    - 関数内で書き換える必要がある場合
    - コピーしたくない(サイズが大きい、ファイル型を扱う等)場合
- 引数やレシーバに通常の変数を入れると、オブジェクトがコピーされる
- 〃にポインタを入れると、GCの兼ね合いで若干非効率になる